#include <render/shader.hpp>
#include <system\defines.hpp>

#include <d3d12shader.h>
#include <d3dx12.h>

#include <array>

namespace shaders
{
	std::array<shader*, SHADER_END> shaders;

	bool loadResources()
	{
		{
			Microsoft::WRL::ComPtr<IDxcUtils> pUtils;
			Microsoft::WRL::ComPtr<IDxcCompiler3> pCompiler;
			DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));
			DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&pCompiler));

			//
			// Create default include handler. (You can create your own...)
			//
			Microsoft::WRL::ComPtr<IDxcIncludeHandler> pIncludeHandler;
			pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

			LPCWSTR pszArgs[] =
			{
L"data/shader/source/pbr.vs.cso",
L"-E", L"VSMain",              // Entry point.
L"-T", L"vs_6_5",            // Target.
L"-Zs",                      // Enable debug information (slim format)
L"-D", L"MYDEFINE=1",        // A single define.
L"-Fo", L"",     // Optional. Stored in the pdb. 
L"-Fd", L"",     // The file name of the pdb. This must either be supplied
// or the autogenerated file name must be used.
L"-Qstrip_reflect",          // Strip reflection into a separate blob. 
			};

			//
// Open source file.  
//
			Microsoft::WRL::ComPtr<IDxcBlobEncoding> pSource = nullptr;
			pUtils->LoadFile(L"data/shader/source/pbr.vs", nullptr, &pSource);
			DxcBuffer Source;
			Source.Ptr = pSource->GetBufferPointer();
			Source.Size = pSource->GetBufferSize();
			Source.Encoding = DXC_CP_ACP; // Assume BOM says UTF8 or UTF16 or this is ANSI text.

			//
// Compile it with specified arguments.
//
			Microsoft::WRL::ComPtr<IDxcResult> pResults;
			pCompiler->Compile(
				&Source,                // Source buffer.
				pszArgs,                // Array of pointers to arguments.
				_countof(pszArgs),      // Number of arguments.
				pIncludeHandler.Get(),        // User-provided interface to handle #include directives (optional).
				IID_PPV_ARGS(&pResults) // Compiler output status, buffer, and errors.
			);

			//
			// Print errors if present.
			//
			Microsoft::WRL::ComPtr<IDxcBlobUtf8> pErrors = nullptr;
			pResults->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&pErrors), nullptr);
			// Note that d3dcompiler would return null if no errors or warnings are present.
			// IDxcCompiler3::Compile will always return an error buffer, but its length
			// will be zero if there are no warnings or errors.re
			if (pErrors != nullptr && pErrors->GetStringLength() != 0)
				printf("Warnings and Errors:\n%S\n", pErrors->GetStringPointer());

			//
			// Quit if the compilation failed.
			//
			HRESULT hrStatus;
			pResults->GetStatus(&hrStatus);
			if (FAILED(hrStatus))
			{
				wprintf(L"Compilation Failed\n");
				return 1;
			}

			shader* newShader = new shader();

			newShader->setshaderSource(pResults);
			newShader->setInput({
				{"POSITION", DXGI_FORMAT_R32G32B32_FLOAT},
				{"NORMAL", DXGI_FORMAT_R32G32B32_FLOAT}
				});

			shaders[PBR_VS] = newShader;

			//const D3D_SHADER_MACRO defines[] =
			//{
			//	"EXAMPLE_DEFINE", "1",
			//	NULL, NULL
			//};

			//ID3DBlob* shaderBlob = nullptr;
			//ID3DBlob* errorBlob = nullptr;

			//HRESULT hr = D3DCompileFromFile(L"data/shader/source/pbr.vs", defines, D3D_COMPILE_STANDARD_FILE_INCLUDE,
			//	"VSMain", "vs_6_5", D3DCOMPILE_ENABLE_STRICTNESS | D3DCOMPILE_DEBUG, 0, &shaderBlob, &errorBlob);

			//if (FAILED(hr))
			//{
			//	if (errorBlob)
			//	{
			//		OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			//		errorBlob->Release();
			//	}

			//	if (shaderBlob)
			//		shaderBlob->Release();
			//}
		}

		{
 		//	shader* newShader = new shader();

			//newShader->load(L"data/shader/pbr.vs.cso");
			//newShader->setInput({
			//	{"POSITION", DXGI_FORMAT_R32G32B32_FLOAT},
			//	{"NORMAL", DXGI_FORMAT_R32G32B32_FLOAT}
			//	});

			//shaders[PBR_VS] = newShader;
		}

		{
			shader* newShader = new shader();

			newShader->load(L"data/shader/pbr.ps.cso");

			shaders[PBR_PS] = newShader;
		}

		return true;
	}

	void cleanup()
	{
		for (uint i = 0; i < SHADER_END; ++i)
		{
			shaders[i]->close();
			delete shaders[i];
		}
	}

	shader* getShader(const SHADER_INDEX index)
	{
		return shaders[index];
	}
}

void shader::load(std::wstring filename)
{
	Microsoft::WRL::ComPtr<IDxcUtils> pUtils;
	DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&pUtils));

	Microsoft::WRL::ComPtr<IDxcIncludeHandler> pIncludeHandler;
	pUtils->CreateDefaultIncludeHandler(&pIncludeHandler);

	pIncludeHandler->LoadSource(filename.c_str(), &shaderSource);
}

void shader::close()
{
	inputs.clear();

	shaderSource->Release();
}

void shader::setInput(std::vector<inputDesc> input)
{
	uint index = 0;
	for (auto desc : input)
	{
		inputs.push_back({ desc.name, 0, desc.format, index, 0, D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA, 0 });
		++index;
	}
}

void shader::setshaderSource(Microsoft::WRL::ComPtr<IDxcResult> result)
{
	Microsoft::WRL::ComPtr<IDxcBlobUtf16> pShaderName = nullptr;
	result->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderSource), &pShaderName);
}

D3D12_SHADER_BYTECODE shader::getByteCode() const
{
	return CD3DX12_SHADER_BYTECODE(shaderSource->GetBufferPointer(), shaderSource->GetBufferSize());
}
